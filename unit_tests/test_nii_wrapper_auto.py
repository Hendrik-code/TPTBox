# Generated by CodiumAI
from __future__ import annotations

import os
import tempfile
import unittest
from pathlib import Path

import nibabel as nib
import numpy as np
import pytest
from nibabel import Nifti1Header, Nifti1Image

import TPTBox
from TPTBox.core.nii_wrapper import NII


class TestNII(unittest.TestCase):
    # Test that an instance of the NII class can be created with valid parameters.
    def test_valid_parameters(self):
        # Create a Nifti1Image object for testing
        data = np.zeros((10, 10, 10))
        affine = np.eye(4)
        header = Nifti1Header()
        nii = Nifti1Image(data, affine, header)

        # Create an instance of the NII class with valid parameters
        nii_obj = NII(nii, seg=True, c_val=0)

        # Assert that the instance is created successfully
        assert isinstance(nii_obj, NII)
        assert nii_obj.nii == nii
        assert nii_obj.seg
        self.assertEqual(nii_obj.c_val, 0)

    # Test that the 'get_seg_array' method returns the segmentation array when the NII object is set as a segmentation.
    def test_get_seg_array(self):
        # Create a NII object with a segmentation array
        seg_array = np.array([[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0]], dtype=np.int16)
        nii = NII(Nifti1Image(seg_array, np.eye(4)), seg=True)

        # Call the 'get_seg_array' method
        result = nii.get_seg_array()

        # Check that the result is equal to the original segmentation array
        assert np.array_equal(result, seg_array)

    # Test that the get_c_val method returns the default value when c_val is None.
    def test_get_c_val_with_default(self):
        # Create a NII instance with c_val set to None
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), np.eye(4)), seg=False, c_val=None)

        # Call the get_c_val method with a default value
        result = nii.get_c_val(default=100)

        # Assert that the result is equal to the default value
        assert result == 100, result

    # Test that accessing the 'array' property of an NII object that is not set as a segmentation returns the correct array.
    def test_get_array_not_seg(self):
        # Create a NII object with seg=False
        r = np.random.random((10, 10, 10))
        nii = NII(Nifti1Image(r, np.eye(4)), seg=False)

        # Access the 'array' property
        arr = nii.get_array()

        # Check that the returned array is correct
        assert np.array_equal(arr, r)

    # Test that setting the orientation property of the NII class to a valid value correctly updates the orientation.
    def test_set_orientation_valid_value(self):
        # Create a NII object with a known orientation
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), np.eye(4)), seg=False)

        # Set the orientation property to a valid value
        nii.reorient_(("R", "A", "I"))
        # Check that the orientation has been updated correctly
        assert nii.orientation == ("R", "A", "I")

    # Test that the load method of the NII class successfully loads an image using a valid path.
    def test_load_valid_path(self):
        # Create a temporary directory and file
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_file = Path(temp_dir, "test.nii.gz")
            # Create a dummy Nifti image
            data = np.zeros((10, 10, 10))
            affine = np.eye(4)
            nii = Nifti1Image(data, affine)
            nib.save(nii, temp_file)

            # Load the image using the load method
            loaded_nii = NII.load(temp_file, seg=False)

            # Assert that the loaded image is of type NII
            assert isinstance(loaded_nii, NII)

            # Assert that the loaded image has the correct attributes
            assert isinstance(loaded_nii.nii, Nifti1Image)
            assert not loaded_nii.seg
            assert loaded_nii.c_val is None
            Path(temp_file).unlink()

    # Test that the 'set_array' method properly sets the array property of the NII object with a valid array.
    def test_set_array_valid_array(self):
        # Create a NII object
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), np.eye(4)), seg=True)

        # Create a valid array
        arr = np.ones((10, 10, 10))

        # Set the array property using the 'set_array' method
        nii.set_array_(arr)

        # Check if the array property is properly set
        assert np.array_equal(nii.get_array(), arr)

    # Test that setting the dtype property with a valid data type updates the data type of the NII object.
    def test_set_dtype_valid(self):
        # Create a NII object with a random array and dtype
        arr = np.random.rand(10, 10, 10)
        nii = NII(Nifti1Image(arr, np.eye(4)), seg=False)
        dtype_before = nii.dtype

        # Set the dtype property to a valid data type
        nii.set_dtype_(np.uint16)
        dtype_after = nii.dtype

        # Assert that the dtype has been updated
        assert dtype_after == np.uint16
        assert dtype_after != dtype_before, (dtype_after, dtype_before)

    # Test that the global_to_local method correctly converts global coordinates to local coordinates.
    def test_global_to_local(self):
        # Create a NII object with a known affine matrix
        affine = np.array([[1, 0, 0, 10], [0, 1, 0, 20], [0, 0, 1, 30], [0, 0, 0, 1]])
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), affine), seg=False)

        # Define a global coordinate
        global_coord = (15, 25, 35)

        # Convert the global coordinate to local coordinate using the global_to_local method
        local_coord = nii.global_to_local(global_coord)

        # Assert that the local coordinate is correct
        assert local_coord == (5, 5, 5)

    # Test that the local_to_global method correctly converts local coordinates to global coordinates.
    def test_local_to_global_conversion(self):
        # Create a NII object with a known affine matrix
        affine = np.array([[1, 0, 0, 10], [0, 1, 0, 20], [0, 0, 1, 30], [0, 0, 0, 1]])
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), affine), seg=False)

        # Define a local coordinate
        local_coord = (5, 5, 5)

        # Convert the local coordinate to global coordinate
        global_coord = nii.local_to_global(local_coord)

        # Check if the global coordinate is correct
        assert global_coord == (15.0, 25.0, 35.0)

    # Test that the reorient method correctly reorients the image to the specified orientation.
    def test_reorient_image(self):
        # Create a test image
        data = np.zeros((10, 10, 10), dtype=np.uint8)
        affine = np.eye(4)
        nii = Nifti1Image(data, affine)
        image = NII(nii)

        # Reorient the image to a different orientation
        new_orientation = ("R", "A", "S")
        reoriented_image = image.reorient(axcodes_to=new_orientation)

        # Check that the orientation of the reoriented image matches the specified orientation
        assert reoriented_image.orientation == new_orientation

    # Test that the map_labels method raises an AssertionError when called on a None NII object.
    def test_map_labels_with_none_nii(self):
        with pytest.raises(AssertionError):
            nii = NII(None)
            nii.map_labels({1: 2})

    # Test that the compute_crop_slice method returns the correct crop slice for the image.
    def test_compute_crop_slice(self):
        # Create a test image
        arr = np.zeros((100, 100, 100))
        s = (slice(5, 95), slice(5, 95), slice(5, 95))
        arr[s] = 1
        image = NII(Nifti1Image(arr, np.eye(4)), seg=True)

        # Compute the crop slice
        crop_slice = image.compute_crop(minimum=0, dist=0)

        # Check that the crop slice is correct
        assert crop_slice == s

    # Test that the map_labels method correctly maps labels in the segmentation mask.
    def test_map_labels(self):
        # Create a segmentation mask with multiple labels
        mask_data = np.array([[[0, 1, 1, 0], [0, 2, 2, 0], [0, 3, 3, 0], [0, 0, 0, 0]]], dtype=np.uint16)
        mask_affine = np.eye(4)
        mask = NII(Nifti1Image(mask_data, mask_affine), seg=True)

        # Define the label mapping
        label_map = {1: 10, 2: 20, 3: 30}

        # Apply the label mapping
        mapped_mask = mask.map_labels(label_map)

        # Check that the labels have been correctly mapped
        expected_data = np.array([[[0, 10, 10, 0], [0, 20, 20, 0], [0, 30, 30, 0], [0, 0, 0, 0]]], dtype=np.uint16)
        assert np.array_equal(mapped_mask.get_seg_array(), expected_data)

    # Test that the apply_crop_slice method correctly applies the crop slice to the image.
    def test_apply_crop_slice(self):
        # Create a test image
        image = NII(Nifti1Image(np.zeros((100, 100, 100)), np.eye(4)), seg=True)

        # Apply a crop slice
        crop_slice = (slice(10, 90), slice(10, 90), slice(10, 90))
        cropped_image = image.apply_crop(crop_slice)

        # Check that the shape of the cropped image is correct
        assert cropped_image.shape == (80, 80, 80)

        # Check that the data in the cropped image is correct
        assert np.all(cropped_image.get_array() == np.zeros((80, 80, 80)))

    # Test that the rescale_and_reorient method properly rescales and reorients the image to the specified voxel spacing.
    def test_rescale_and_reorient(self):
        # Create a test image
        img = NII(Nifti1Image(np.zeros((100, 100, 100)), np.eye(4)), seg=False)

        # Rescale and reorient the image
        voxel_spacing = (2, 2, 2)
        axcodes_to = ("P", "I", "R")
        rescaled_img = img.rescale_and_reorient(voxel_spacing=voxel_spacing, axcodes_to=axcodes_to)

        # Check if the shape of the rescaled image matches the expected shape
        assert rescaled_img.shape == (50, 50, 50)

        # Check if the zoom of the rescaled image matches the expected zoom
        assert rescaled_img.zoom == voxel_spacing

        # Check if the orientation of the rescaled image matches the expected orientation
        assert rescaled_img.orientation == axcodes_to

    # Test that the get_plane method returns the correct plane of the image.
    def test_get_plane(self):
        # Create a NII object with a known affine matrix
        affine = np.array([[1.0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), affine), seg=False)

        # Test for sagittal plane
        affine[0, 0] = 0.5
        nii.affine = affine
        assert nii.get_plane(res_threshold=0) == "sag", nii.get_plane()
        assert nii.get_plane(res_threshold=1) == "iso"
        # Test for coronal plane
        affine[0, 0] = 1
        affine[1, 1] = 0.5
        nii.affine = affine
        assert nii.get_plane(res_threshold=0) == "cor"
        assert nii.get_plane(res_threshold=1) == "iso"
        # Test for axial plane
        affine[1, 1] = 1.0
        affine[2, 2] = 0.5
        nii.affine = affine
        assert nii.get_plane(res_threshold=0) == "ax"
        assert nii.get_plane(res_threshold=1) == "iso"

        # Test for isometric plane
        affine[0, 0] = 1
        affine[1, 1] = 1
        affine[2, 2] = 1
        nii.affine = affine
        assert nii.get_plane(res_threshold=0) == "iso"

    # Test that the erode_msk method correctly erodes the segmentation mask.
    def test_erode_msk(self):
        # Create a test NII object with a segmentation mask
        nii = NII(Nifti1Image(np.array([[[0, 0, 0], [0, 1, 0], [0, 0, 0]]], dtype=np.int16), np.eye(4)), seg=True)

        # Erode the segmentation mask
        nii_eroded = nii.erode_msk(n_pixel=1)

        # Check that the eroded mask is correct
        assert np.array_equal(nii_eroded.get_seg_array(), np.array([[[0, 0, 0], [0, 0, 0], [0, 0, 0]]]))

        # Check that the original NII object is not modified
        assert np.array_equal(nii.get_seg_array(), np.array([[[0, 0, 0], [0, 1, 0], [0, 0, 0]]]))

    # Test that the dilate_msk method correctly dilates the segmentation mask.
    def test_dilate_msk(self):
        # Create a test NII object with a segmentation mask
        data = np.zeros((10, 10, 10), dtype=np.uint16)
        data[4:7, 4:7, 4:7] = 1
        nii = NII(Nifti1Image(data, np.eye(4)), seg=True)

        # Dilate the segmentation mask
        nii.dilate_msk_(n_pixel=1, connectivity=3)

        # Check that the dilated mask is correct
        expected = np.zeros((10, 10, 10), dtype=np.uint16)
        expected[3:8, 3:8, 3:8] = 1
        assert np.array_equal(nii.get_seg_array(), expected), (nii.get_seg_array()[5], expected[5])

    # Test that the fill_holes method correctly fills holes in the segmentation mask.
    def test_fill_holes(self):
        # Create a test NII object with a segmentation mask
        # TODO: this test works only in 2D, which is not supported by NII
        nii = NII(
            Nifti1Image(
                np.array(
                    [
                        [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                        [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                        [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                    ],
                    dtype=np.int16,
                ),
                np.eye(4),
            ),
            seg=True,
        )

        # Fill the holes in the segmentation mask
        nii.fill_holes_()

        # Check that the holes are filled correctly
        expected_result = np.array(
            [
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
            ]
        )
        assert np.array_equal(nii.get_seg_array(), expected_result), (nii.get_seg_array(), expected_result)

    # Test that the save method correctly saves the image to a file.
    def test_save_method(self):
        # Create a temporary directory to save the file
        with tempfile.TemporaryDirectory() as temp_dir:
            # Create a NII object
            nii = NII(Nifti1Image(np.zeros((10, 10, 10)), np.eye(4)), seg=True)

            # Save the image to a file
            file_path = Path(temp_dir, "test.nii.gz")
            nii.save(file_path)

            # Check if the file exists
            assert Path(file_path)

            # Load the saved image
            loaded_nii = NII.load(file_path, seg=True)

            # Check if the loaded image is equal to the original image
            assert np.array_equal(nii.get_array(), loaded_nii.get_array())

    # Test that loading an image using the load method with an invalid path raises a ValueError.
    def test_load_invalid_path(self):
        with pytest.raises(FileNotFoundError):
            NII.load("invalid_path.nii.gz", seg=True)

    # Test that the load_bids method raises an AssertionError when given a BIDS file with an invalid file format.
    def test_load_bids_invalid_file_format(self):
        with pytest.raises(FileNotFoundError):
            NII.load_bids(TPTBox.BIDS_FILE(file="invalid_file.nii.gz", dataset="/"))

    # Test that setting the orientation property to an invalid value raises an AssertionError.
    def test_invalid_orientation(self):
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), np.eye(4)), seg=True)
        with pytest.raises(ValueError):
            nii.orientation = ("X", "Y", "Z")

    # Test that the get_c_val method returns the custom default value when c_val is None.
    def test_get_c_val_with_custom_default(self):
        # Create a NII instance with c_val set to None
        nii = NII(Nifti1Image(np.zeros((10, 10, 10)), np.eye(4)), seg=False, c_val=None)

        # Set a custom default value
        custom_default = -1

        # Call the get_c_val method with the custom default value
        result = nii.get_c_val(default=custom_default)

        # Assert that the result is equal to the custom default value
        assert result == custom_default

    # Test that accessing the seg_array property of an NII object that is not set as a segmentation raises a warning.
    def test_get_seg_array_not_seg(self):
        import warnings

        # Create a Nifti1Image object
        data = np.zeros((10, 10, 10))
        affine = np.eye(4)
        nii = Nifti1Image(data, affine)

        # Create an NII object with seg=False
        nii_obj = NII(nii, seg=False)

        # Access the seg_array property and check for warning
        with warnings.catch_warnings(record=True) as w:
            _ = nii_obj.get_seg_array()
            assert len(w) == 1
            assert issubclass(w[-1].category, UserWarning)
            assert "requested a segmentation array, but NII is not set as a segmentation" in str(w[-1].message)

    # Test that the 'get_array' method returns the segmentation array when the NII object is set as a segmentation.
    def test_get_array_segmentation(self):
        # Create a NII object with a segmentation array
        seg_array = np.array([[0, 0, 0], [1, 1, 1], [0, 0, 0]], dtype=np.int16)
        nii = NII(Nifti1Image(seg_array, np.eye(4)), seg=True)

        # Call the 'get_array' method
        result = nii.get_array()

        # Assert that the result is equal to the segmentation array
        assert np.array_equal(result, seg_array)

    # Test that the unique method returns the correct unique labels in the segmentation mask.
    def test_unique_method(self):
        # Create a segmentation mask with multiple labels
        mask = np.array([[0, 1, 1, 0], [0, 2, 2, 0], [0, 1, 1, 0]], dtype=np.int16)

        # Create a NII object with the segmentation mask
        nii = NII(Nifti1Image(mask, np.eye(4)), seg=True)

        # Get the unique labels using the unique method
        unique_labels = nii.unique()

        # Check that the unique labels are correct
        assert unique_labels[0] == 1
        assert unique_labels[1] == 2
        assert len(unique_labels) == 2

    # Test that the volumes method returns the correct volumes for each label in the segmentation mask.
    def test_volumes_method(self):
        # Create a segmentation mask with labeled regions
        mask_data = np.array([[0, 1, 1, 0], [0, 1, 2, 0], [0, 0, 2, 0], [0, 0, 0, 0]], dtype=np.int16)
        mask_affine = np.eye(4)
        mask = NII(Nifti1Image(mask_data, mask_affine), seg=True)

        # Calculate the volumes of each label
        volumes = mask.volumes()
        print(volumes)

        # Check that the volumes are correct
        assert volumes == {1: 3, 2: 2}, volumes

        # Calculate the volumes of each label
        volumes = mask.volumes(include_zero=True)
        print(volumes)

        # Check that the volumes are correct
        assert volumes == {0: 11, 1: 3, 2: 2}, volumes

    # Test that the is_intersecting_vertical method returns True when two images are intersecting vertically.
    def test_is_intersecting_vertical_true(self):
        # Create two NII objects with overlapping vertical slices
        a = np.eye(4)
        b = np.eye(4)
        a[2, 3] = 50
        b[2, 3] = 60

        img1 = NII(Nifti1Image(np.ones((100, 100, 100)), a), seg=True)
        img2 = NII(Nifti1Image(np.ones((100, 100, 100)), b), seg=True)

        # Check if the images are intersecting vertically
        result = img1.is_intersecting_vertical(img2, min_overlap=1)

        # Assert that the result is True
        assert result is True

    # Test that the extract_label method correctly extracts a specific label from the segmentation mask.
    def test_extract_label(self):
        # Create a NII object with a segmentation mask
        mask = np.array(
            [
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 2, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 2, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 2, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 2, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 2, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]],
            ],
            dtype=np.uint16,
        )
        affine = np.eye(4)
        nii = Nifti1Image(mask, affine)
        seg = NII(nii, seg=True)

        # Extract label '2' from the segmentation mask
        extracted = seg.extract_label(2)

        # Check that the extracted mask only contains label '2'
        expected = np.array(
            [
                [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
                [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
            ],
            dtype=np.uint16,
        )

        assert np.array_equal(extracted.get_seg_array(), expected), (extracted.get_seg_array(), expected)
